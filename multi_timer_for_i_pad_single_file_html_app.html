<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>現場向け・多重カウントダウンタイマー (iPad対応)</title>
<style>
  :root {
    --bg:#0f172a; --panel:#111827; --panel-2:#1f2937; --panel-3:#0b1220;
    --text:#e5e7eb; --muted:#9ca3af; --ok:#34d399; --warn:#fbbf24; --danger:#f87171; --accent:#60a5fa;
  }
  *{box-sizing:border-box;-webkit-tap-highlight-color:transparent}
  body {background:var(--bg);color:var(--text);font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial;margin:0;}
  header{position:sticky;top:0;z-index:20;background:rgba(17,24,39,.9);backdrop-filter:blur(6px);border-bottom:1px solid #1f2937}
  .wrap{max-width:1100px;margin:0 auto;padding:10px 16px}
  h1{margin:0 0 6px;font-size:20px;font-weight:800}
  .toolbar{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  button{background:var(--panel-2);color:var(--text);border:1px solid #374151;border-radius:10px;padding:8px 12px;font-weight:600;cursor:pointer}
  button:disabled{opacity:.5}
  .btn-prim{background:#1d4ed8;border-color:#1e40af}
  .btn-ok{background:#065f46;border-color:#064e3b}
  .btn-warn{background:#92400e;border-color:#7c2d12}
  .btn-danger{background:#7f1d1d;border-color:#7f1d1d}
  input[type="text"],input[type="search"]{background:var(--panel-2);color:var(--text);border:1px solid #374151;border-radius:10px;padding:8px 12px}
  .pill{background:var(--panel-3);border:1px solid #1f2937;color:var(--text);border-radius:999px;padding:6px 10px;font-size:13px}
  .list{padding:16px;display:flex;flex-direction:column;gap:10px}
  .row{background:var(--panel);border:1px solid #1f2937;border-radius:14px;padding:10px;display:grid;grid-template-columns:1.2fr .9fr 1fr auto;gap:10px;align-items:center}
  .time{font-variant-numeric:tabular-nums;font-size:26px;font-weight:800}
  .progress{width:100%;height:12px;background:var(--panel-3);border:1px solid #1f2937;border-radius:999px;overflow:hidden}
  .bar{height:100%;width:0%;background:linear-gradient(90deg,#22c55e,#84cc16);transition:width .3s}
  .status{font-size:12px;color:var(--muted)}
  .presets{display:flex;flex-wrap:wrap;gap:6px}
  .btns{display:flex;flex-wrap:wrap;gap:6px}
  .badge{position:relative}
  .badge::after{content:attr(data-badge);position:absolute;top:-8px;right:-8px;background:#ef4444;color:#fff;font-size:12px;font-weight:800;padding:2px 6px;border-radius:999px;display:none}
  .badge[data-badge]:not([data-badge=""])::after{display:inline-block}
  .flash{animation:flash .5s linear 10}
  @keyframes flash{0%{background:#1f2937}50%{background:#7c3aed}100%{background:#1f2937}}
  .hint{font-size:12px;color:var(--muted)}
  .muted{color:var(--muted)}
  /* modal */
  .modal{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.45);z-index:50}
  .modal-inner{background:#0b1220;border:1px solid #1f2937;color:var(--text);border-radius:16px;max-width:520px;width:92%;padding:16px}
  .modal h3{margin:0 0 8px;font-size:18px}
  .modal ul{margin:8px 0 12px;padding-left:18px}
</style>
</head>
<body>
<header>
  <div class="wrap">
    <h1>多重カウントダウンタイマー <span class="hint">(最大50 / iPad最適化 / ローカル保存)</span></h1>
    <div class="toolbar">
      <button id="addTimer" class="btn-prim">＋ 新規タイマー</button>
      <button id="exportCsv">CSV書き出し</button>
      <button id="clearLog" class="btn-danger">ログ全削除</button>
      <button id="enableSound" class="btn-ok">音を有効化/テスト</button>
      <span id="completeBadge" class="badge pill" data-badge="">同時完了</span>
      <input id="search" type="search" placeholder="検索 (タイトル)" style="flex:1 1 260px"/>
      <span class="hint">※ iOSは初回に「音を有効化/テスト」を押してください</span>
    </div>
  </div>
</header>
<main class="wrap">
  <div class="list" id="list"></div>
  <p class="muted">ログはイベント時のみ記録（Start/Pause/Reset/Completed/Extend/Delete/Rename/Create）。CSVで出力可能。状態とログはlocalStorageに保存。</p>
</main>

<!-- 完了モーダル -->
<div id="doneModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="doneTitle">
  <div class="modal-inner">
    <h3 id="doneTitle">タイマー完了</h3>
    <p class="muted">以下のタイマーが完了しました：</p>
    <ul id="doneList"></ul>
    <div style="display:flex;gap:8px;justify-content:flex-end">
      <button id="doneStop" class="btn-warn">音を止める</button>
      <button id="doneOk" class="btn-prim">OK</button>
    </div>
  </div>
</div>

<script>
(() => {
  const MAX_TIMERS = 50;
  const listEl = document.getElementById('list');
  const addBtn = document.getElementById('addTimer');
  const exportBtn = document.getElementById('exportCsv');
  const clearBtn = document.getElementById('clearLog');
  const searchEl = document.getElementById('search');
  const badgeEl = document.getElementById('completeBadge');
  const enableSoundBtn = document.getElementById('enableSound');
  const modal = document.getElementById('doneModal');
  const modalList = document.getElementById('doneList');
  const modalOk = document.getElementById('doneOk');
  const modalStop = document.getElementById('doneStop');

  // ======= Audio (iOS requires user gesture) =======
  let audioCtx = null; let beepInterval = null; let unlocked = false;
  function ensureAudio(){
    if (!audioCtx) {
      try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); } catch(e){}
    } else if (audioCtx.state === 'suspended') { audioCtx.resume(); }
    unlocked = !!audioCtx;
    return audioCtx;
  }
  function tone(freq = 1000, dur = 0.12, type='square', gain=0.12){
    const ctx = ensureAudio(); if (!ctx) return;
    const o = ctx.createOscillator(); const g = ctx.createGain();
    o.type = type; o.frequency.setValueAtTime(freq, ctx.currentTime);
    g.gain.setValueAtTime(0.0001, ctx.currentTime);
    g.gain.exponentialRampToValueAtTime(gain, ctx.currentTime + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + dur);
    o.connect(g).connect(ctx.destination); o.start(); o.stop(ctx.currentTime + dur);
  }
  // "ピピピピピピ" 連続パターン
  function beepPatternOnce(){
    const ctx = ensureAudio(); if (!ctx) return;
    const base = ctx.currentTime;
    const pattern = [1200, 1200, 1200, 1200, 1200, 1200]; // 6連続
    pattern.forEach((f,i)=>{
      const o = ctx.createOscillator(); const g = ctx.createGain();
      o.type='square'; o.frequency.setValueAtTime(f, base + i*0.16);
      g.gain.setValueAtTime(0.001, base + i*0.16);
      g.gain.exponentialRampToValueAtTime(0.16, base + i*0.17);
      g.gain.exponentialRampToValueAtTime(0.0001, base + i*0.28);
      o.connect(g).connect(ctx.destination); o.start(base + i*0.16); o.stop(base + i*0.3);
    });
  }
  function startRepeatingBeep(){
    stopRepeatingBeep();
    beepPatternOnce();
    beepInterval = setInterval(beepPatternOnce, 1200); // 約1.2秒ごとに繰返し
  }
  function stopRepeatingBeep(){ if (beepInterval){ clearInterval(beepInterval); beepInterval = null; } }

  enableSoundBtn.addEventListener('click', () => { ensureAudio(); beepPatternOnce(); });

  // ======= Helpers =======
  const nowIso = () => new Date().toISOString();
  const fmt = (sec) => { const s=Math.max(0,Math.floor(sec)); const m=Math.floor(s/60); const r=s%60; return `${String(m).padStart(2,'0')}:${String(r).padStart(2,'0')}`; };
  const uid = () => Math.random().toString(36).slice(2,10);

  // ======= State & Persistence =======
  const state = { timers:{}, order:[], log:[], completeSlots:{} };
  const LS_KEY = 'multiTimersV3';
  const load = () => { try{ const raw = localStorage.getItem(LS_KEY); if(!raw) return; const obj = JSON.parse(raw); ['timers','order','log','completeSlots'].forEach(k=>{ if(obj[k]!==undefined) state[k]=obj[k]; }); }catch(e){} };
  const save = () => { localStorage.setItem(LS_KEY, JSON.stringify(state)); };

  function logEvent(id, name, type, detail=""){ state.log.push({ ts: nowIso(), id, name, type, detail }); if (state.log.length % 5 === 0) save(); }

  // ======= Timer Model =======
  function newTimerObj(total){ return { id:uid(), name:'タイマー', total, remain:total, running:false, createdAt:nowIso(), updatedAt:nowIso(), flashed:false }; }

  // 入力: 90s / 3m / 5m30s / 120
  function parseDuration(text){
    if(!text) return null;
    const t = text.trim();
    const mm = t.match(/(\d+)m/i); const ss = t.match(/(\d+)s/i);
    let sec = 0; if (mm) sec += parseInt(mm[1])*60; if (ss) sec += parseInt(ss[1]);
    if (!mm && !ss) sec = parseInt(t)||0;
    return sec>0? sec : null;
  }

  function addTimer(initial){
    if (state.order.length >= MAX_TIMERS){ alert(`最大 ${MAX_TIMERS} 個までです`); return; }
    const t = Object.assign(newTimerObj(initial.total), initial);
    state.timers[t.id]=t; state.order.push(t.id);
    logEvent(t.id, t.name, 'Create', `total=${t.total}`);
    render(); save();
  }

  function promptNewTimer(){
    const v = prompt('タイマー時間を入力 (例: 90s, 3m, 5m30s, 120)');
    if (v===null) return;
    const sec = parseDuration(v);
    if (!sec){ alert('正しい値を入力してください'); return; }
    addTimer({ total:sec, remain:sec });
  }

  function deleteTimer(id){ const t=state.timers[id]; if(!t) return; if(!confirm(`「${t.name}」を削除しますか？`)) return; logEvent(t.id, t.name, 'Delete'); delete state.timers[id]; state.order=state.order.filter(x=>x!==id); render(); save(); }
  function startTimer(id){ const t=state.timers[id]; if(!t||t.running) return; if(t.remain<=0){ t.remain=t.total; } t.running=true; t.updatedAt=nowIso(); logEvent(t.id,t.name,'Start',`remain=${t.remain}`); renderRow(id); }
  function pauseTimer(id){ const t=state.timers[id]; if(!t||!t.running) return; t.running=false; t.updatedAt=nowIso(); logEvent(t.id,t.name,'Pause',`remain=${t.remain}`); renderRow(id); save(); }
  function resetTimer(id){ const t=state.timers[id]; if(!t) return; if(!confirm(`「${t.name}」をリセットしますか？ 初期 ${fmt(t.total)} に戻ります。`)) return; t.remain=t.total; t.running=false; t.flashed=false; t.updatedAt=nowIso(); logEvent(t.id,t.name,'Reset'); renderRow(id); save(); }
  function extendTimer(id, sec){ const t=state.timers[id]; if(!t) return; const before=t.remain; t.remain=Math.max(0,t.remain+sec); t.updatedAt=nowIso(); const sign=sec>=0?'+':''; logEvent(t.id,t.name,'Extend',`${sign}${sec}s (from ${before} to ${t.remain})`); renderRow(id); save(); }
  function renameTimer(id, name){ const t=state.timers[id]; if(!t) return; const before=t.name; t.name=name||'タイマー'; if(before!==t.name) logEvent(t.id,t.name,'Rename',`from "${before}"`); save(); }

  // ======= Engine =======
  setInterval(() => {
    let completed = [];
    state.order.forEach(id => {
      const t = state.timers[id]; if(!t) return;
      if (t.running && t.remain>0){
        t.remain -= 1;
        if (t.remain<=0){
          t.remain=0; t.running=false; t.updatedAt=nowIso(); logEvent(t.id,t.name,'Completed');
          completed.push({id, name:t.name});
          const row=document.getElementById(`row-${id}`); if(row){ row.classList.add('flash'); setTimeout(()=>row.classList.remove('flash'), 4000); }
        }
        renderRow(id);
      }
    });
    if (completed.length){
      // 同一秒に完了した数 = バッジ
      const k=new Date(); k.setMilliseconds(0); const key=k.toISOString();
      const n = (state.completeSlots[key]||0) + completed.length; state.completeSlots[key]=n; badgeEl.setAttribute('data-badge', String(n));
      // モーダルに列挙 + 連続ビープ開始
      modalList.innerHTML = completed.map(c=>`<li>${c.name}</li>`).join('');
      modal.style.display='flex';
      if (unlocked) startRepeatingBeep();
      save();
    }
  }, 1000);

  // ======= Render =======
  function render(){
    const q=(searchEl.value||'').trim().toLowerCase();
    listEl.innerHTML='';
    state.order.forEach(id=>{
      const t=state.timers[id]; if(!t) return; if(q && !t.name.toLowerCase().includes(q)) return; listEl.appendChild(renderRow(id,true));
    });
    if (!listEl.children.length){ const d=document.createElement('div'); d.className='muted'; d.textContent='「＋ 新規タイマー」で作成。プリセットで残り時間を加算できます。'; listEl.appendChild(d); }
  }

  function renderRow(id, create=false){
    const t=state.timers[id]; if(!t) return; let row=document.getElementById(`row-${id}`);
    if (create || !row){
      row=document.createElement('div'); row.className='row'; row.id=`row-${id}`;
      row.innerHTML = `
        <div>
          <input type="text" id="name-${id}" value="${t.name}" aria-label="タイトル">
          <div class="status" id="status-${id}"></div>
        </div>
        <div>
          <div class="time" id="time-${id}">00:00</div>
          <div class="progress"><div class="bar" id="bar-${id}"></div></div>
          <div class="status">合計 <span id="total-${id}">${fmt(t.total)}</span></div>
        </div>
        <div class="presets" id="presets-${id}"></div>
        <div class="btns">
          <button id="start-${id}" class="btn-ok">Start</button>
          <button id="pause-${id}">Pause</button>
          <button id="reset-${id}" class="btn-warn">Reset</button>
          <button id="del-${id}" class="btn-danger">Delete</button>
        </div>`;
      listEl.appendChild(row);
      // events
      row.querySelector(`#name-${id}`).addEventListener('change',e=>renameTimer(id,e.target.value));
      row.querySelector(`#start-${id}`).addEventListener('click',()=>startTimer(id));
      row.querySelector(`#pause-${id}`).addEventListener('click',()=>pauseTimer(id));
      row.querySelector(`#reset-${id}`).addEventListener('click',()=>resetTimer(id));
      row.querySelector(`#del-${id}`).addEventListener('click',()=>deleteTimer(id));
      // presets
      const p = row.querySelector(`#presets-${id}`);
      const mk=(label,sec)=>{ const b=document.createElement('button'); b.textContent=label; b.className='pill'; b.addEventListener('click',()=>extendTimer(id,sec)); return b; };
      p.append(mk('+1s',1), mk('+5s',5), mk('+10s',10), mk('+15s',15), document.createTextNode(' '), mk('+1m',60), mk('+5m',300), mk('+10m',600), mk('+60m',3600));
    }
    row.querySelector(`#time-${id}`).textContent = fmt(t.remain);
    row.querySelector(`#total-${id}`).textContent = fmt(t.total);
    const pct = t.total>0 ? Math.max(0, Math.min(100, (1-(t.remain/t.total))*100)) : 0;
    row.querySelector(`#bar-${id}`).style.width = pct.toFixed(1)+'%';
    row.querySelector(`#status-${id}`).textContent = t.running ? '実行中' : (t.remain===0? '完了' : '停止中');
    row.querySelector(`#start-${id}`).disabled = t.running;
    row.querySelector(`#pause-${id}`).disabled = !t.running;
    return row;
  }

  // ======= CSV Export =======
  function toCsv(){ const head='timestamp,timer_id,timer_name,event,detail\n'; const esc=(s)=>'"'+String(s).replaceAll('"','""')+'"'; const rows=state.log.map(e=>[e.ts,e.id,e.name,e.type,e.detail].map(esc).join(',')); return head+rows.join('\n'); }
  function download(filename, text){ const a=document.createElement('a'); a.href=URL.createObjectURL(new Blob([text],{type:'text/csv;charset=utf-8;'})); a.download=filename; a.click(); setTimeout(()=>URL.revokeObjectURL(a.href), 2000); }

  // ======= Toolbar actions =======
  addBtn.addEventListener('click', promptNewTimer);
  exportBtn.addEventListener('click', () => { if(!state.log.length){ alert('ログがありません'); return; } const ts=new Date().toISOString().replaceAll(':','-').replace('T','_').slice(0,19); download(`timers_log_${ts}.csv`, toCsv()); });
  clearBtn.addEventListener('click', () => { if(!state.log.length){ alert('ログは空です'); return; } if(!confirm('ログをすべて削除しますか？ CSV出力してからの削除を推奨します。')) return; state.log=[]; save(); alert('ログを削除しました'); });
  searchEl.addEventListener('input', render);

  // modal actions
  function closeModal(){ modal.style.display='none'; stopRepeatingBeep(); badgeEl.setAttribute('data-badge',''); }
  modalOk.addEventListener('click', closeModal);
  modalStop.addEventListener('click', stopRepeatingBeep);

  // ======= Init =======
  load(); if(!Array.isArray(state.order)) state.order = Object.keys(state.timers);
  render();
  if (state.order.length===0){ addTimer({ name:'例: 3分', total:180, remain:180 }); addTimer({ name:'例: 10分', total:600, remain:600 }); save(); }

  window.addEventListener('beforeunload', save);
})();
</script>
</body>
</html>